# 内存溢出诊断指南

根据崩溃日志分析，这是 Hermes 内存溢出（OOM）导致的硬崩溃。本指南提供系统性的诊断和修复方案。

## 🔍 快速诊断实验

### 实验 A：不调用 AI，返回固定小回复

**目的**：判断问题是否在 AI 请求/响应处理

**步骤**：
1. 在 `handleSend` 函数中，注释掉 AI 调用部分
2. 直接返回固定小回复（如 "ok"）
3. 测试是否还会闪退

**结果判断**：
- ✅ **不闪退**：问题在 AI 请求/响应处理（响应太大、解析、状态更新）
- ❌ **仍闪退**：问题在 UI 组件/渲染链（组件重渲染、无限循环）

**代码位置**：参考 `app/app/chat/[id].tsx.diagnostic` 文件中的 `handleSend_EXPERIMENT_A`

---

### 实验 B：调用 AI，但不渲染结果

**目的**：判断问题是否在 setState + 渲染

**步骤**：
1. 让 AI 请求正常执行
2. 收到响应后，**只打印到控制台**，不调用 `setMessages`
3. 测试是否还会闪退

**结果判断**：
- ✅ **不闪退**：问题在 setState + 渲染（最常见）
- ❌ **仍闪退**：问题在响应读取/解析（一次性读入超大文本、JSON 过大）

**代码位置**：参考 `app/app/chat/[id].tsx.diagnostic` 文件中的 `handleSend_EXPERIMENT_B`

---

## 📊 已添加的诊断日志

代码中已添加诊断日志，会在控制台输出：

1. **请求计数**：每次发送消息时打印请求编号
   ```
   [诊断] 发送消息 #1
   [诊断] 请求 #1 开始调用AI服务...
   ```

2. **响应大小**：AI 响应的大小（字符数和 KB）
   ```
   [诊断] 请求 #1 AI回复大小: 1234 字符 (1.21 KB)
   [诊断] API原始响应大小: 1234 字符 (1.21 KB)
   ```

3. **setState 前检查**：准备更新状态时的消息对象大小
   ```
   [诊断] 请求 #1 准备setState，消息对象大小: 1500 字符
   [诊断] 请求 #1 setState完成，消息总数: 5
   ```

**查看方法**：
- 在 Expo Go 中打开开发者菜单
- 选择 "Open JS Debugger"
- 在 Chrome DevTools 的 Console 中查看日志

---

## 🔧 已实施的修复

### 1. 响应大小限制
- **API 响应**：最多 50KB（JSON 解析前）
- **AI 回复内容**：最多 2000 字符（约 4KB 内存）
- **用户消息**：最多 200 字符
- **系统提示词**：最多 200 字符

### 2. 消息数组限制
- **内存中**：最多 50 条消息
- **存储中**：最多 50 条消息
- 所有 `setMessages` 调用都会检查并限制数组大小

### 3. 请求计数器
- 每次发送消息时递增计数器
- 用于检测无限循环（如果一次点击触发多次请求）

### 4. 状态更新优化
- 使用循环而非 `filter` + 展开运算符
- 减少临时对象创建
- 延迟存储操作，避免阻塞 UI

---

## 🎯 根据诊断结果定位问题

### 如果实验 A 不闪退（问题在 AI 请求/响应）

**可能原因**：
1. **响应太大**：API 返回了超大文本
   - 检查控制台日志中的响应大小
   - 如果超过 2000 字符，需要进一步限制

2. **JSON 解析问题**：响应 JSON 结构过大
   - 检查 `qianwenService.ts` 中的响应解析
   - 已限制响应文本为 50KB

3. **状态更新问题**：每次更新都复制整个数组
   - 已优化为循环方式
   - 检查是否有其他地方也在频繁更新

### 如果实验 B 不闪退（问题在 setState + 渲染）

**可能原因**：
1. **FlatList 渲染问题**：消息列表渲染导致内存压力
   - 检查是否使用了 `FlatList`（已使用）
   - 检查是否有 `removeClippedSubviews={false}`（已设置）

2. **长文本渲染**：单条消息过长导致渲染压力
   - 已限制单条消息最多 2000 字符
   - 考虑添加"折叠/展开"功能

3. **频繁重渲染**：组件频繁重新渲染
   - 已使用 `React.memo` 优化组件
   - 检查是否有其他依赖导致重渲染

### 如果两个实验都闪退（问题在 UI 组件/逻辑循环）

**可能原因**：
1. **无限循环**：useEffect 依赖导致无限循环
   - 已修复 `useEffect` 依赖项问题
   - 检查控制台是否有重复的请求日志

2. **组件内存泄漏**：组件卸载时未清理资源
   - 已添加定时器清理
   - 检查是否有其他未清理的资源

---

## 🚨 紧急兜底方案

如果问题仍然存在，可以临时实施以下兜底方案：

### 1. 进一步限制响应大小
在 `qianwenService.ts` 中：
```typescript
const maxResponseLength = 500; // 从 2000 减少到 500
```

### 2. 禁用自动回复
在 `chat/[id].tsx` 中注释掉自动回复的 `useEffect`

### 3. 减少消息数组限制
```typescript
const MAX_MESSAGES_IN_MEMORY = 20; // 从 50 减少到 20
```

### 4. 完全禁用 AI 功能
临时注释掉所有 AI 调用，只保留 UI 交互

---

## 📝 下一步

1. **运行实验 A 和 B**，告诉我结果
2. **查看控制台日志**，检查响应大小和请求计数
3. **如果发现异常**（如响应过大、请求重复），告诉我具体数值

根据诊断结果，我可以进一步精确修复问题。



